/**
 * Copyright (c) 2023, R8V.
 * BSD Zero Clause License.
 */

package cl.ravenhill.keen.util

import cl.ravenhill.keen.arbs.datatypes.real
import io.kotest.core.spec.style.FreeSpec
import io.kotest.matchers.shouldBe
import io.kotest.property.Arb
import io.kotest.property.RandomSource
import io.kotest.property.arbitrary.arbitrary
import io.kotest.property.arbitrary.double
import io.kotest.property.arbitrary.int
import io.kotest.property.arbitrary.next
import io.kotest.property.arbitrary.positiveInt
import io.kotest.property.assume
import io.kotest.property.checkAll
import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.sqrt

// region : -== ARBITRARY GENERATORS ==-
/**
 * Generates an [Arb]itrary [Pair] of [Int]s, where the first element is a positive integer and the
 * second element is a positive divisor of the first element.
 */
private fun Arb.Companion.intAndDivisor() = arbitrary { rs ->
    val number = Arb.positiveInt().bind()
    val divisor = number
        .divisors(rs)
        .first()
    number to divisor
}

/**
 * Generates an [Arb]itrary [Pair] of [Int]s, where the first element is a positive integer and the
 * second element is a positive non-divisor of the first element.
 */
private fun Arb.Companion.nonDivisiblePair() = arbitrary { rs ->
    val number = Arb.int(3, Int.MAX_VALUE).bind()
    val nonDivisor = number
        .nonDivisors(rs)
        .take(1)
        .first()
    number to nonDivisor
}

/**
 * Returns an [Arb] that generates pairs of doubles with a difference of at most 1e-10.
 * The first element is generated by [Arb.Companion.double] and the second element is obtained by
 * adding a random double value in the range [0.0, 1e-10] to the first element.
 */
private fun Arb.Companion.closePair() = arbitrary {
    val a = Arb.double().next()
    val b = a + Arb.double(0.0..1e-10).next()
    a to b
}

/**
 * Returns an [Arb] that generates pairs of doubles with a difference of at least 1e-10.
 * The first element is generated by [Arb.Companion.double] and the second element is obtained by
 * adding a random double value in the range [1e-10, 1.0] to the first element.
 */
private fun Arb.Companion.farPair() = arbitrary {
    val a = Arb.double().next()
    val maxDiff = Double.MAX_VALUE - a
    val b = if (maxDiff > 1e-10) {
        a + Arb.double(1e-10..maxDiff).next()
    } else {
        Double.MAX_VALUE
    }
    a to b
}
// endregion ARBITRARY GENERATORS

// region : -== AUXILIARY FUNCTIONS ==-
/**
 * Returns a sequence of all divisors of this [Int] instance, shuffled using the given [rs]
 * [RandomSource].
 * The divisors are generated lazily using the Sieve of Eratosthenes algorithm and are not
 * guaranteed to be in any particular order.
 *
 * ## References
 *
 * 1. “Sieve of Eratosthenes.” In Wikipedia, April 18, 2023.
 *    https://en.wikipedia.org/w/index.php?title=Sieve_of_Eratosthenes&oldid=1150503937.
 */
private fun Int.divisors(rs: RandomSource) = sequence {
    // Initialize the loop counter and the maximum value to check
    val n = this@divisors.toDouble()
    // Loop through all numbers between 1 and the square root of n
    for (i in 1 until sqrt(n).toInt() + 1) {
        // If ``i`` is a divisor, yield it and its complement (if it's not a perfect square)
        if (n % i == 0.0) {
            yield(i)
            // If ``i`` is not equal to n/i (the other divisor), add it to the sequence too
            if (i != (n / i).toInt()) yield((n / i).toInt())
        }
    }
}.shuffled(rs.random)

/**
 * Returns a randomly ordered lazy [Sequence] of all the non-divisors of this [Int].
 */
private fun Int.nonDivisors(rs: RandomSource) =
    generateSequence { rs.random.nextInt(this) }
        .filter { it >= 2 && this % it != 0 }

/**
 * Iterates over each element in the provided vararg `elements` and performs the provided
 * `action` on each.
 *
 * ## Examples
 * ### Example 1: Iterating over an array of numbers
 * ```
 * val numbers = arrayOf(1, 2, 3, 4, 5)
 * iterateOverElements(*numbers) { println(it) }
 * ```
 * ### Example 2: Iterating over a list of strings
 * ```
 * val strings = arrayOf("apple", "banana", "cherry")
 * iterateOverElements(*strings) { println(it) }
 * ```
 *
 * @param T The type of elements in the `elements` vararg.
 * @param elements Vararg of elements to be iterated over.
 * @param action A higher-order function to be applied on each element.
 */
inline fun <T> iterateOverElements(vararg elements: T, action: (T) -> Unit) =
    elements.forEach(action)
// endregion AUXILIARY FUNCTIONS

class NumbersTest : FreeSpec({
    "Rounding a number to the next multiple of another number" - {
        "the number is a multiple of the other number" - {
            "return the same number" {
                checkAll(Arb.intAndDivisor()) { (number, divisor) ->
                    number roundUpToMultipleOf divisor shouldBe number
                }
            }
        }

        "the number is not a multiple of the other number" - {
            "return the next multiple of the other number" {
                checkAll(
                    Arb.nonDivisiblePair()
                ) { (number, nonDivisor) ->
                    number roundUpToMultipleOf nonDivisor shouldBe
                            number + nonDivisor - number % nonDivisor
                }
            }
        }
    }

    "Calculating the ceiling of a [Double] should" - {
        "return the ceiling of a real number" {
            checkAll(Arb.real()) { n ->
                n.ceil() shouldBe ceil(n).toInt()
            }
        }

        "return 0 if the number is a NaN" {
            Double.NaN.ceil() shouldBe 0
        }

        "return the ceiling of a positive infinity" {
            Double.POSITIVE_INFINITY.ceil() shouldBe Int.MAX_VALUE
        }

        "return the ceiling of a negative infinity" {
            Double.NEGATIVE_INFINITY.ceil() shouldBe Int.MIN_VALUE
        }
    }

    "Calculating the floor of a [Double] should" - {
        "return the floor of a real number" {
            checkAll(Arb.real()) { n ->
                n.floor() shouldBe floor(n).toInt()
            }
        }

        "return 0 if the number is a NaN" {
            Double.NaN.floor() shouldBe 0
        }

        "return the floor of a positive infinity" {
            Double.POSITIVE_INFINITY.floor() shouldBe Int.MAX_VALUE
        }

        "return the floor of a negative infinity" {
            Double.NEGATIVE_INFINITY.floor() shouldBe Int.MIN_VALUE
        }
    }

    "Checking that a number is not a NaN" - {
        "return true if the number is not a NaN" {
            checkAll(Arb.double()) { d ->
                assume(!d.isNaN())
                d.isNotNan() shouldBe true
            }
        }

        "return false if the number is a NaN" {
            val nan = Double.NaN
            nan.isNotNan() shouldBe false
        }
    }

    "[Double] equality should" - {
        "be true for the same number" {
            checkAll(Arb.closePair()) { (a, b) ->
                a shouldEq b
            }
        }

        "be false for two different numbers" {
            checkAll(Arb.farPair()) { (a, b) ->
                a shouldNeq b
            }
        }

        "be false for two NaNs" {
            Double.NaN shouldNeq Double.NaN
        }
    }
})
