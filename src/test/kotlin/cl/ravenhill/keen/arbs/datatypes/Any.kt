/*
 * Copyright (c) 2023, Ignacio Slater M.
 * 2-Clause BSD License.
 */


package cl.ravenhill.keen.arbs.datatypes

import io.kotest.property.Arb
import io.kotest.property.arbitrary.arbitrary
import io.kotest.property.arbitrary.boolean
import io.kotest.property.arbitrary.byte
import io.kotest.property.arbitrary.char
import io.kotest.property.arbitrary.choice
import io.kotest.property.arbitrary.double
import io.kotest.property.arbitrary.float
import io.kotest.property.arbitrary.int
import io.kotest.property.arbitrary.long
import io.kotest.property.arbitrary.short
import io.kotest.property.arbitrary.string

/**
 * Returns an arbitrary generator that produces values of [Any] type.
 * The generated values can be of the following types:
 * [String], [Int], [Long], [Double], [Float], [Boolean], [Char], [Byte], [Short].
 *
 * All the types are generated with the default generators provided by _Kotest_.
 */
fun Arb.Companion.any() = arbitrary {
    choice(
        string(),
        int(),
        long(),
        double(),
        float(),
        boolean(),
        char(),
        byte(),
        short()
    ).bind()
}

/**
 * Creates a generator for producing pairs where the second element's generation is dependent on the first element.
 *
 * This function extends the functionality of an [Arb] by allowing the creation of a second arbitrary generator
 * that depends on the value generated by the first. This is particularly useful in scenarios where the
 * properties or constraints of the second element are determined by the first element.
 *
 * ## Usage Example:
 *
 * ### Example: Generating Pairs with Dependent Ranges
 * ```
 * val composedArb = Arb.int(1..100).compose { upper ->
 *     // Generates an Arb<Int> with a range dependent on the 'upper' value
 *     Arb.int(0..upper)
 * }
 * checkAll(composedArb, Arb.int(1..100)) { (upper, lower), value ->
 *     // Test implementation using 'upper', 'lower', and 'value'
 * }
 * ```
 * In this example, `composedArb` first generates a random integer `upper` and then uses it to generate a
 * second integer `lower` within a range from 0 to `upper`. This approach allows for testing a wide range
 * of scenarios where the range or properties of the second value depend on the first.
 *
 * @param T The type of the first element generated.
 * @param U The type of the second element, which is dependent on the first.
 * @param other A lambda function that takes a value of type [T] and returns an [Arb] of type [U].
 *
 * @return An [Arb] that generates pairs of [T] and [U], where [U] is dependent on the generated [T].
 */
fun <T, U> Arb<T>.compose(other: (T) -> Arb<U>) = arbitrary {
    val value = bind()
    value to other(value).bind()
}
